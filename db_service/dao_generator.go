// Copyright 2018 the Service Broker Project Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build ignore

// This program generates dao.go It can be invoked by running
// go generate
package main

import (
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

func main() {
	models := []crudModel{
		{
			Type:            "ServiceInstanceDetails",
			PrimaryKeyType:  "string",
			PrimaryKeyField: "id",
		},
		{
			Type:            "CloudOperation",
			PrimaryKeyType:  "uint",
			PrimaryKeyField: "id",
		},
		{
			Type:            "ServiceBindingCredentials",
			PrimaryKeyType:  "uint",
			PrimaryKeyField: "id",
		},
		{
			Type:            "ProvisionRequestDetails",
			PrimaryKeyType:  "uint",
			PrimaryKeyField: "id",
		},
	}

	createDao(models)
	createDaoTest(models)
}

func createDao(models []crudModel) {
	f, err := os.Create("dao.go")
	die(err)
	defer f.Close()

	daoTemplate.Execute(f, struct {
		Timestamp time.Time
		Models    []crudModel
	}{
		Timestamp: time.Now(),
		Models:    models,
	})
}

func createDaoTest(models []crudModel) {
	f, err := os.Create("dao_test.go")
	die(err)
	defer f.Close()

	daoTestTemplate.Execute(f, struct {
		Timestamp time.Time
		Models    []crudModel
	}{
		Timestamp: time.Now(),
		Models:    models,
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

type crudModel struct {
	Type              string
	PrimaryKeyType    string
	PrimaryKeyField   string
	ExamplePrimaryKey string
}

func snakeToProper(in string) string {
	out := ""
	for _, word := range strings.Split(in, "_") {
		if len(word) == 0 {
			continue
		}

		out += strings.ToUpper(word[0:1]) + strings.ToLower(word[1:])
	}

	return out
}

func functionNameGen(operation string, model crudModel, keys ...string) string {
	out := operation + model.Type
	for i, key := range keys {
		if i == 0 {
			out += "By"
		} else {
			out += "And"
		}

		out += snakeToProper(key)
	}

	return out
}

var daoTemplate = template.Must(template.New("").Funcs(
	template.FuncMap{
		"funcName": functionNameGen,
	},
).Parse(`// Copyright {{ .Timestamp.Year }} the Service Broker Project Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}.

package db_service

import (
	"github.com/GoogleCloudPlatform/gcp-service-broker/brokerapi/brokers/models"
)

{{- range .Models}}

// {{funcName "Count" . .PrimaryKeyField}} gets the count of {{.Type}} by {{.PrimaryKeyField}} in the datastore (0 or 1)
func {{funcName "Count" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (int, error) { return defaultDatastore().{{funcName "Count" . .PrimaryKeyField}}(pk) }
func (ds *SqlDatastore) {{funcName "Count" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (int, error) {
	var count int
	err := ds.db.Model(&models.{{.Type}}{}).Where("{{.PrimaryKeyField}} = ?", pk).Count(&count).Error
	return count, err
}

// {{funcName "Create" .}} creates a new record in the database and assigns it a primary key.
func {{funcName "Create" .}}(object *models.{{.Type}}) error { return defaultDatastore().{{funcName "Create" .}}(object) }
func (ds *SqlDatastore) Create{{.Type}}(object *models.{{.Type}}) error {
	return ds.db.Create(object).Error
}

// {{funcName "Save" .}} updates an existing record in the database.
func {{funcName "Save" .}}(object *models.{{.Type}}) error { return defaultDatastore().{{funcName "Save" .}}(object) }
func (ds *SqlDatastore) {{funcName "Save" .}}(object *models.{{.Type}}) error {
	return ds.db.Save(object).Error
}

// {{funcName "Delete" . .PrimaryKeyField}} soft-deletes the record.
func {{funcName "Delete" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) error { return defaultDatastore().{{funcName "Delete" . .PrimaryKeyField}}(pk) }
func (ds *SqlDatastore) {{funcName "Delete" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) error {
	record, err := ds.{{funcName "Get" . .PrimaryKeyField}}(pk)
	if err != nil {
		return err
	}

	return ds.{{funcName "Delete" .}}(record)
}

// Delete{{.Type}} soft-deletes the record.
func {{funcName "Delete" .}}(record *models.{{.Type}}) error { return defaultDatastore().{{funcName "Delete" .}}(record) }
func (ds *SqlDatastore) {{funcName "Delete" .}}(record *models.{{.Type}}) error {
	return ds.db.Delete(record).Error
}

// {{funcName "Get" . .PrimaryKeyField}} gets an instance of {{.Type}} by its primary key.
// If the record does not exist, brokerapi.ErrInstanceDoesNotExist is returned.
func {{funcName "Get" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (*models.{{.Type}}, error) { return defaultDatastore().{{funcName "Get" . .PrimaryKeyField}}(pk) }
func (ds *SqlDatastore) {{funcName "Get" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (*models.{{.Type}}, error) {
	record := models.{{.Type}}{}
	if err := ds.db.Where("{{.PrimaryKeyField}} = ?", pk).First(&record).Error; err != nil {
		return nil, err
	}

	return &record, nil
}

// {{funcName "CheckDeleted" . .PrimaryKeyField}} checks to see if an instance of {{.Type}} was soft deleted.
func {{funcName "CheckDeleted" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (bool, error) { return defaultDatastore().{{funcName "CheckDeleted" . .PrimaryKeyField}}(pk) }
func (ds *SqlDatastore) {{funcName "CheckDeleted" . .PrimaryKeyField}}(pk {{.PrimaryKeyType}}) (bool, error) {
	record := models.{{.Type}}{}
	if err := ds.db.Unscoped().Where("{{.PrimaryKeyField}} = ?", pk).First(&record).Error; err != nil {
		return false, err
	}

	return record.DeletedAt != nil, nil
}

{{- end }}
`))

var daoTestTemplate = template.Must(template.New("").Funcs(
	template.FuncMap{
		"funcName": functionNameGen,
	},
).Parse(`// Copyright {{ .Timestamp.Year }} the Service Broker Project Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go generate; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}.

package db_service

import (
	"testing"
	"time"

  "github.com/GoogleCloudPlatform/gcp-service-broker/brokerapi/brokers/models"
	"github.com/jinzhu/gorm"
)

func newInMemoryDatastore(t *testing.T) *SqlDatastore {
	testDb, err := gorm.Open("sqlite3", ":memory:")
	if err != nil {
		t.Fatalf("Error opening test database %s", err)
	}

	{{range .Models}}testDb.CreateTable(models.{{.Type}}{})
	{{end}}
	return &SqlDatastore{db: testDb}
}


{{- range .Models}}

func TestSqlDatastore_{{.Type}}DAO(t *testing.T) {
	ds := newInMemoryDatastore(t)
	testPk := {{.PrimaryKeyType}}(42)

	instance := models.{{.Type}}{}
	instance.ID = testPk

	// on startup, there should be no objects to find or delete
	if count, err := ds.{{funcName "Count" . .PrimaryKeyField}}(testPk); count != 0 || err != nil {
		t.Fatalf("Expected count to be 0 and error to be nil got count: %d, err: %v", count, err)
	}

	if _, err := ds.{{funcName "Get" . .PrimaryKeyField}}(testPk); err != gorm.ErrRecordNotFound {
		t.Errorf("Expected an ErrRecordNotFound trying to get non-existing PK got %v", err)
	}

	if _, err := ds.{{funcName "CheckDeleted" . .PrimaryKeyField}}(testPk); err != gorm.ErrRecordNotFound {
		t.Errorf("Expected an ErrRecordNotFound trying to check deletion status of a non-existing PK got %v", err)
	}

	if err := ds.{{funcName "Delete" . .PrimaryKeyField}}(testPk); err != gorm.ErrRecordNotFound {
		t.Errorf("Expected an ErrRecordNotFound trying to delete non-existing PK got %v", err)
	}

	// Should be able to create the item
	beforeCreation := time.Now()
	if err := ds.{{funcName "Create" .}}(&instance); err != nil {
		t.Errorf("Expected to be able to create the item %#v, got error: %s", instance, err)
	}
	afterCreation := time.Now()

	// after creation we should be able to get the item
	ret, err := ds.{{funcName "Get" . .PrimaryKeyField}}(testPk)
	if err != nil {
		t.Errorf("Expected no error trying to get saved item, got: %v", err)
	}

	if ret.CreatedAt.Before(beforeCreation) || ret.CreatedAt.After(afterCreation) {
		t.Errorf("Expected creation time to be between  %v and %v got %v", beforeCreation, afterCreation, ret.CreatedAt)
	}

	if !ret.UpdatedAt.Equal(ret.CreatedAt) {
		t.Errorf("Expected initial update time to equal creation time, but got update: %v, create: %v", ret.UpdatedAt, ret.CreatedAt)
	}

	// we should be able to update the item and it will have a new updated time
	if err := ds.{{funcName "Save" .}}(ret); err != nil {
		t.Errorf("Expected no error trying to get update %#v , got: %v", ret, err)
	}

	// after deleting the item we should not be able to get it
	deleted, err := ds.{{funcName "CheckDeleted" . .PrimaryKeyField}}(testPk)
	if err != nil {
		t.Errorf("Expected no error when checking if a non-deleted thing was deleted")
	}
	if deleted {
		t.Errorf("Expected a non-deleted instance to not be marked as deleted but it was.")
	}

	if err := ds.{{funcName "Delete" . .PrimaryKeyField}}(testPk); err != nil {
		t.Errorf("Expected no error when deleting by pk got: %v", err)
	}

	// we should be able to see that it was soft-deleted
	deleted, err = ds.{{funcName "CheckDeleted" . .PrimaryKeyField}}(testPk)
	if err != nil {
		t.Errorf("Expected no error when checking if a non-deleted thing was deleted")
	}
	if !deleted {
		t.Errorf("Expected a deleted instance to marked as deleted but it was not.")
	}

	// after deleting the item we should not be able to get it
	if _, err := ds.{{funcName "Get" . .PrimaryKeyField}}(testPk); err != gorm.ErrRecordNotFound {
		t.Errorf("Expected ErrRecordNotFound after delete but got %v", err)
	}
}

{{- end }}
`))
